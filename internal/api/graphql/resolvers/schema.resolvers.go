package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"silbackendassessment/internal/api/graphql/graph"
	models "silbackendassessment/internal/api/graphql/graph/model"
	"silbackendassessment/internal/core/domain"
	"time"

	"github.com/google/uuid"
)

// ID is the resolver for the id field.
func (r *categoryResolver) ID(ctx context.Context, obj *domain.Category) (string, error) {
	return obj.ID.String(), nil
}

// ParentID is the resolver for the parentId field.
func (r *categoryResolver) ParentID(ctx context.Context, obj *domain.Category) (*string, error) {
	if obj.ParentID == nil {
		return nil, nil
	}
	s := obj.ParentID.String()
	return &s, nil
}

// ID is the resolver for the id field.
func (r *customerResolver) ID(ctx context.Context, obj *domain.Customer) (string, error) {
	return obj.ID.String(), nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input models.CreateUserInput) (*domain.User, error) {
	req := &domain.CreateUserRequest{Name: input.Name, Email: input.Email}
	return r.userService.CreateUser(ctx, req)
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input models.UpdateUserInput) (*domain.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	req := &domain.UpdateUserRequest{}
	if input.Name != nil {
		req.Name = input.Name
	}
	if input.Email != nil {
		req.Email = input.Email
	}
	return r.userService.UpdateUser(ctx, uid, req)
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}
	if err := r.userService.DeleteUser(ctx, uid); err != nil {
		return false, err
	}
	return true, nil
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input models.CreateCustomerInput) (*domain.Customer, error) {
	req := &domain.CreateCustomerRequest{
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Email:     input.Email,
	}
	if input.Phone != nil {
		req.Phone = *input.Phone
	}
	if input.Address != nil {
		req.Address = *input.Address
	}
	if input.City != nil {
		req.City = *input.City
	}
	if input.State != nil {
		req.State = *input.State
	}
	if input.ZipCode != nil {
		req.ZipCode = *input.ZipCode
	}
	if input.Country != nil {
		req.Country = *input.Country
	}
	return r.customerService.CreateCustomer(ctx, req)
}

// UpdateCustomer is the resolver for the updateCustomer field.
func (r *mutationResolver) UpdateCustomer(ctx context.Context, id string, input models.UpdateCustomerInput) (*domain.Customer, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	req := &domain.UpdateCustomerRequest{}
	if input.FirstName != nil {
		req.FirstName = input.FirstName
	}
	if input.LastName != nil {
		req.LastName = input.LastName
	}
	if input.Phone != nil {
		req.Phone = input.Phone
	}
	if input.Address != nil {
		req.Address = input.Address
	}
	if input.City != nil {
		req.City = input.City
	}
	if input.State != nil {
		req.State = input.State
	}
	if input.ZipCode != nil {
		req.ZipCode = input.ZipCode
	}
	if input.Country != nil {
		req.Country = input.Country
	}
	return r.customerService.UpdateCustomer(ctx, uid, req)
}

// DeleteCustomer is the resolver for the deleteCustomer field.
func (r *mutationResolver) DeleteCustomer(ctx context.Context, id string) (bool, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}
	if err := r.customerService.DeleteCustomer(ctx, uid); err != nil {
		return false, err
	}
	return true, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input models.CreateCategoryInput) (*domain.Category, error) {
	req := &domain.CreateCategoryRequest{Name: input.Name}
	if input.Description != nil {
		req.Description = *input.Description
	}
	if input.ParentID != nil {
		pid, err := uuid.Parse(*input.ParentID)
		if err != nil {
			return nil, err
		}
		req.ParentID = &pid
	}
	return r.categoryService.CreateCategory(ctx, req)
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, id string, input models.UpdateCategoryInput) (*domain.Category, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	req := &domain.UpdateCategoryRequest{}
	if input.Name != nil {
		req.Name = input.Name
	}
	if input.Description != nil {
		req.Description = input.Description
	}
	if input.ParentID != nil {
		pid, err := uuid.Parse(*input.ParentID)
		if err != nil {
			return nil, err
		}
		req.ParentID = &pid
	}
	return r.categoryService.UpdateCategory(ctx, uid, req)
}

// DeleteCategory is the resolver for the deleteCategory field.
func (r *mutationResolver) DeleteCategory(ctx context.Context, id string) (bool, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}
	if err := r.categoryService.DeleteCategory(ctx, uid); err != nil {
		return false, err
	}
	return true, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input models.CreateProductInput) (*domain.Product, error) {
	cid, err := uuid.Parse(input.CategoryID)
	if err != nil {
		return nil, err
	}
	req := &domain.CreateProductRequest{
		Name:       input.Name,
		SKU:        input.Sku,
		Price:      input.Price,
		Stock:      int(input.Stock),
		CategoryID: cid,
		IsActive:   true,
	}
	if input.Description != nil {
		req.Description = *input.Description
	}
	if input.IsActive != nil {
		req.IsActive = *input.IsActive
	}
	return r.productService.CreateProduct(ctx, req)
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input models.UpdateProductInput) (*domain.Product, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	req := &domain.UpdateProductRequest{}
	if input.Name != nil {
		req.Name = input.Name
	}
	if input.Description != nil {
		req.Description = input.Description
	}
	if input.Sku != nil {
		req.SKU = input.Sku
	}
	if input.Price != nil {
		req.Price = input.Price
	}
	if input.Stock != nil {
		v := int(*input.Stock)
		req.Stock = &v
	}
	if input.CategoryID != nil {
		cid, err := uuid.Parse(*input.CategoryID)
		if err != nil {
			return nil, err
		}
		req.CategoryID = &cid
	}
	if input.IsActive != nil {
		req.IsActive = input.IsActive
	}
	return r.productService.UpdateProduct(ctx, uid, req)
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}
	if err := r.productService.DeleteProduct(ctx, uid); err != nil {
		return false, err
	}
	return true, nil
}

// UpdateProductStock is the resolver for the updateProductStock field.
func (r *mutationResolver) UpdateProductStock(ctx context.Context, id string, stock int32) (*domain.Product, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	if err := r.productService.UpdateStock(ctx, uid, int(stock)); err != nil {
		return nil, err
	}
	return r.productService.GetProduct(ctx, uid)
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input models.CreateOrderInput) (*domain.Order, error) {
	cid, err := uuid.Parse(input.CustomerID)
	if err != nil {
		return nil, err
	}
	items := make([]domain.CreateOrderItemRequest, 0, len(input.OrderItems))
	for _, it := range input.OrderItems {
		pid, err := uuid.Parse(it.ProductID)
		if err != nil {
			return nil, err
		}
		items = append(items, domain.CreateOrderItemRequest{ProductID: pid, Quantity: int(it.Quantity)})
	}
	req := &domain.CreateOrderRequest{CustomerID: cid, ShippingAddress: input.ShippingAddress, BillingAddress: input.BillingAddress, OrderItems: items}
	if input.Notes != nil {
		req.Notes = *input.Notes
	}
	return r.orderService.CreateOrder(ctx, req)
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, id string, input models.UpdateOrderInput) (*domain.Order, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	req := &domain.UpdateOrderRequest{}
	if input.Status != nil {
		req.Status = input.Status
	}
	if input.ShippingAddress != nil {
		req.ShippingAddress = input.ShippingAddress
	}
	if input.BillingAddress != nil {
		req.BillingAddress = input.BillingAddress
	}
	if input.Notes != nil {
		req.Notes = input.Notes
	}
	if input.ShippedDate != nil {
		req.ShippedDate = input.ShippedDate
	}
	if input.DeliveredDate != nil {
		req.DeliveredDate = input.DeliveredDate
	}
	return r.orderService.UpdateOrder(ctx, uid, req)
}

// DeleteOrder is the resolver for the deleteOrder field.
func (r *mutationResolver) DeleteOrder(ctx context.Context, id string) (bool, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}
	if err := r.orderService.DeleteOrder(ctx, uid); err != nil {
		return false, err
	}
	return true, nil
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, id string) (*domain.Order, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	if err := r.orderService.CancelOrder(ctx, uid); err != nil {
		return nil, err
	}
	return r.orderService.GetOrder(ctx, uid)
}

// ShipOrder is the resolver for the shipOrder field.
func (r *mutationResolver) ShipOrder(ctx context.Context, id string) (*domain.Order, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	if err := r.orderService.UpdateOrderStatus(ctx, uid, domain.OrderStatusShipped); err != nil {
		return nil, err
	}
	// set shipped date
	t := time.Now()
	_, _ = r.orderService.UpdateOrder(ctx, uid, &domain.UpdateOrderRequest{ShippedDate: &t})
	return r.orderService.GetOrder(ctx, uid)
}

// DeliverOrder is the resolver for the deliverOrder field.
func (r *mutationResolver) DeliverOrder(ctx context.Context, id string) (*domain.Order, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	if err := r.orderService.UpdateOrderStatus(ctx, uid, domain.OrderStatusDelivered); err != nil {
		return nil, err
	}
	// set delivered date
	t := time.Now()
	_, _ = r.orderService.UpdateOrder(ctx, uid, &domain.UpdateOrderRequest{DeliveredDate: &t})
	return r.orderService.GetOrder(ctx, uid)
}

// ID is the resolver for the id field.
func (r *orderResolver) ID(ctx context.Context, obj *domain.Order) (string, error) {
	return obj.ID.String(), nil
}

// CustomerID is the resolver for the customerId field.
func (r *orderResolver) CustomerID(ctx context.Context, obj *domain.Order) (string, error) {
	return obj.CustomerID.String(), nil
}

// ID is the resolver for the id field.
func (r *orderItemResolver) ID(ctx context.Context, obj *domain.OrderItem) (string, error) {
	return obj.ID.String(), nil
}

// OrderID is the resolver for the orderId field.
func (r *orderItemResolver) OrderID(ctx context.Context, obj *domain.OrderItem) (string, error) {
	return obj.OrderID.String(), nil
}

// ProductID is the resolver for the productId field.
func (r *orderItemResolver) ProductID(ctx context.Context, obj *domain.OrderItem) (string, error) {
	return obj.ProductID.String(), nil
}

// Quantity is the resolver for the quantity field.
func (r *orderItemResolver) Quantity(ctx context.Context, obj *domain.OrderItem) (int32, error) {
	return int32(obj.Quantity), nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *domain.Product) (string, error) {
	return obj.ID.String(), nil
}

// Stock is the resolver for the stock field.
func (r *productResolver) Stock(ctx context.Context, obj *domain.Product) (int32, error) {
	return int32(obj.Stock), nil
}

// CategoryID is the resolver for the categoryId field.
func (r *productResolver) CategoryID(ctx context.Context, obj *domain.Product) (string, error) {
	return obj.CategoryID.String(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, pagination *models.PaginationInput) ([]*domain.User, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.userService.GetUsers(ctx, l, o)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*domain.User, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	return r.userService.GetUser(ctx, uid)
}

// SearchUsers is the resolver for the searchUsers field.
func (r *queryResolver) SearchUsers(ctx context.Context, query string, pagination *models.PaginationInput) ([]*domain.User, error) {
	// No search implementation available. Return first page as fallback.
	return r.Users(ctx, pagination)
}

// Customers is the resolver for the customers field.
func (r *queryResolver) Customers(ctx context.Context, pagination *models.PaginationInput) ([]*domain.Customer, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.customerService.GetCustomers(ctx, l, o)
}

// Customer is the resolver for the customer field.
func (r *queryResolver) Customer(ctx context.Context, id string) (*domain.Customer, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	return r.customerService.GetCustomer(ctx, uid)
}

// SearchCustomers is the resolver for the searchCustomers field.
func (r *queryResolver) SearchCustomers(ctx context.Context, query string, pagination *models.PaginationInput) ([]*domain.Customer, error) {
	// No search implementation available. Return first page as fallback.
	return r.Customers(ctx, pagination)
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, pagination *models.PaginationInput) ([]*domain.Category, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.categoryService.GetCategories(ctx, l, o)
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*domain.Category, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	return r.categoryService.GetCategory(ctx, uid)
}

// RootCategories is the resolver for the rootCategories field.
func (r *queryResolver) RootCategories(ctx context.Context, pagination *models.PaginationInput) ([]*domain.Category, error) {
	return r.categoryService.GetRootCategories(ctx)
}

// Subcategories is the resolver for the subcategories field.
func (r *queryResolver) Subcategories(ctx context.Context, parentID string, pagination *models.PaginationInput) ([]*domain.Category, error) {
	pid, err := uuid.Parse(parentID)
	if err != nil {
		return nil, err
	}
	return r.categoryService.GetSubCategories(ctx, pid)
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, filter *models.ProductFilterInput, pagination *models.PaginationInput) ([]*domain.Product, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	if filter != nil && filter.CategoryID != nil {
		cid, err := uuid.Parse(*filter.CategoryID)
		if err != nil {
			return nil, err
		}
		return r.productService.GetProductsByCategory(ctx, cid, l, o)
	}
	if filter != nil && filter.IsActive != nil && *filter.IsActive {
		return r.productService.GetActiveProducts(ctx, l, o)
	}
	if filter != nil && filter.Search != nil && *filter.Search != "" {
		return r.productService.SearchProducts(ctx, *filter.Search, l, o)
	}
	return r.productService.GetProducts(ctx, l, o)
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*domain.Product, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	return r.productService.GetProduct(ctx, uid)
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *queryResolver) ProductsByCategory(ctx context.Context, categoryID string, pagination *models.PaginationInput) ([]*domain.Product, error) {
	cid, err := uuid.Parse(categoryID)
	if err != nil {
		return nil, err
	}
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.productService.GetProductsByCategory(ctx, cid, l, o)
}

// ActiveProducts is the resolver for the activeProducts field.
func (r *queryResolver) ActiveProducts(ctx context.Context, pagination *models.PaginationInput) ([]*domain.Product, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.productService.GetActiveProducts(ctx, l, o)
}

// SearchProducts is the resolver for the searchProducts field.
func (r *queryResolver) SearchProducts(ctx context.Context, query string, pagination *models.PaginationInput) ([]*domain.Product, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.productService.SearchProducts(ctx, query, l, o)
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context, filter *models.OrderFilterInput, pagination *models.PaginationInput) ([]*domain.Order, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	if filter != nil && filter.CustomerID != nil {
		cid, err := uuid.Parse(*filter.CustomerID)
		if err != nil {
			return nil, err
		}
		return r.orderService.GetOrdersByCustomer(ctx, cid, l, o)
	}
	if filter != nil && filter.Status != nil {
		return r.orderService.GetOrdersByStatus(ctx, *filter.Status, l, o)
	}
	return r.orderService.GetOrders(ctx, l, o)
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*domain.Order, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	return r.orderService.GetOrder(ctx, uid)
}

// OrdersByCustomer is the resolver for the ordersByCustomer field.
func (r *queryResolver) OrdersByCustomer(ctx context.Context, customerID string, pagination *models.PaginationInput) ([]*domain.Order, error) {
	cid, err := uuid.Parse(customerID)
	if err != nil {
		return nil, err
	}
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.orderService.GetOrdersByCustomer(ctx, cid, l, o)
}

// OrdersByStatus is the resolver for the ordersByStatus field.
func (r *queryResolver) OrdersByStatus(ctx context.Context, status domain.OrderStatus, pagination *models.PaginationInput) ([]*domain.Order, error) {
	l, o := 10, 0
	if pagination != nil {
		if pagination.Limit != nil {
			l = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			o = int(*pagination.Offset)
		}
	}
	return r.orderService.GetOrdersByStatus(ctx, status, l, o)
}

// OrderByNumber is the resolver for the orderByNumber field.
func (r *queryResolver) OrderByNumber(ctx context.Context, orderNumber string) (*domain.Order, error) {
	return r.orderService.GetOrderByNumber(ctx, orderNumber)
}

// OrderStats is the resolver for the orderStats field.
func (r *queryResolver) OrderStats(ctx context.Context) (*models.OrderStats, error) {
	orders, err := r.orderService.GetOrders(ctx, 10000, 0)
	if err != nil {
		return nil, err
	}
	var totalRevenue float64
	counts := map[domain.OrderStatus]int{}
	var ordersToday int
	var revenueToday float64
	today := time.Now().Format("2006-01-02")
	for _, o := range orders {
		totalRevenue += o.TotalAmount
		counts[o.Status]++
		if o.OrderDate.Format("2006-01-02") == today {
			ordersToday++
			revenueToday += o.TotalAmount
		}
	}
	statusCounts := make([]*models.OrderStatusCount, 0, len(counts))
	for st, c := range counts {
		statusCounts = append(statusCounts, &models.OrderStatusCount{Status: st, Count: int32(c)})
	}
	avg := 0.0
	if len(orders) > 0 {
		avg = totalRevenue / float64(len(orders))
	}
	return &models.OrderStats{
		TotalOrders:       int32(len(orders)),
		TotalRevenue:      totalRevenue,
		OrdersByStatus:    statusCounts,
		AverageOrderValue: avg,
		OrdersToday:       int32(ordersToday),
		RevenueToday:      revenueToday,
	}, nil
}

// ProductStats is the resolver for the productStats field.
func (r *queryResolver) ProductStats(ctx context.Context) (*models.ProductStats, error) {
	products, err := r.productService.GetProducts(ctx, 10000, 0)
	if err != nil {
		return nil, err
	}
	var total, active, inactive, low, out int
	var totalValue float64
	for _, p := range products {
		total++
		if p.IsActive {
			active++
		} else {
			inactive++
		}
		if p.Stock == 0 {
			out++
		}
		if p.Stock < 10 {
			low++
		}
		totalValue += p.Price * float64(p.Stock)
	}
	return &models.ProductStats{
		TotalProducts:       int32(total),
		ActiveProducts:      int32(active),
		InactiveProducts:    int32(inactive),
		LowStockProducts:    int32(low),
		OutOfStockProducts:  int32(out),
		TotalInventoryValue: totalValue,
	}, nil
}

// CustomerStats is the resolver for the customerStats field.
func (r *queryResolver) CustomerStats(ctx context.Context) (*models.CustomerStats, error) {
	customers, err := r.customerService.GetCustomers(ctx, 10000, 0)
	if err != nil {
		return nil, err
	}
	orders, err := r.orderService.GetOrders(ctx, 10000, 0)
	if err != nil {
		return nil, err
	}
	custIdToAgg := map[uuid.UUID]struct {
		total int
		spent float64
		last  *time.Time
	}{}
	for _, o := range orders {
		a := custIdToAgg[o.CustomerID]
		a.total++
		a.spent += o.TotalAmount
		if a.last == nil || (o.OrderDate.After(*a.last)) {
			t := o.OrderDate
			a.last = &t
		}
		custIdToAgg[o.CustomerID] = a
	}
	// top customers simplistic: pick those with any orders
	top := make([]*models.CustomerOrderSummary, 0)
	for _, c := range customers {
		if agg, ok := custIdToAgg[c.ID]; ok {
			top = append(top, &models.CustomerOrderSummary{Customer: c, TotalOrders: int32(agg.total), TotalSpent: agg.spent, LastOrderDate: agg.last})
		}
	}
	// new customers this month
	now := time.Now()
	firstOfMonth := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
	newThisMonth := 0
	for _, c := range customers {
		if c.CreatedAt.After(firstOfMonth) {
			newThisMonth++
		}
	}
	withOrders := len(top)
	return &models.CustomerStats{
		TotalCustomers:        int32(len(customers)),
		NewCustomersThisMonth: int32(newThisMonth),
		CustomersWithOrders:   int32(withOrders),
		TopCustomers:          top,
	}, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *domain.User) (string, error) {
	return obj.ID.String(), nil
}

// Category returns graph.CategoryResolver implementation.
func (r *Resolver) Category() graph.CategoryResolver { return &categoryResolver{r} }

// Customer returns graph.CustomerResolver implementation.
func (r *Resolver) Customer() graph.CustomerResolver { return &customerResolver{r} }

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Order returns graph.OrderResolver implementation.
func (r *Resolver) Order() graph.OrderResolver { return &orderResolver{r} }

// OrderItem returns graph.OrderItemResolver implementation.
func (r *Resolver) OrderItem() graph.OrderItemResolver { return &orderItemResolver{r} }

// Product returns graph.ProductResolver implementation.
func (r *Resolver) Product() graph.ProductResolver { return &productResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type categoryResolver struct{ *Resolver }
type customerResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
