// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"fmt"
	"io"
	"silbackendassessment/internal/core/domain"
	"strconv"
	"time"
)

// Input for creating a new category
type CreateCategoryInput struct {
	// Category name
	Name string `json:"name"`
	// Category description (optional)
	Description *string `json:"description,omitempty"`
	// Parent category ID (optional, null for root categories)
	ParentID *string `json:"parentId,omitempty"`
}

// Input for creating a new customer
type CreateCustomerInput struct {
	// Customer's first name
	FirstName string `json:"firstName"`
	// Customer's last name
	LastName string `json:"lastName"`
	// Email address (must be unique)
	Email string `json:"email"`
	// Phone number (optional)
	Phone *string `json:"phone,omitempty"`
	// Street address (optional)
	Address *string `json:"address,omitempty"`
	// City (optional)
	City *string `json:"city,omitempty"`
	// State or province (optional)
	State *string `json:"state,omitempty"`
	// ZIP or postal code (optional)
	ZipCode *string `json:"zipCode,omitempty"`
	// Country (optional)
	Country *string `json:"country,omitempty"`
}

// Input for creating a new order
type CreateOrderInput struct {
	// Customer ID placing the order
	CustomerID string `json:"customerId"`
	// Shipping address
	ShippingAddress string `json:"shippingAddress"`
	// Billing address
	BillingAddress string `json:"billingAddress"`
	// Additional notes (optional)
	Notes *string `json:"notes,omitempty"`
	// Items to include in the order
	OrderItems []*CreateOrderItemInput `json:"orderItems"`
}

// Input for creating an order item
type CreateOrderItemInput struct {
	// Product ID for this item
	ProductID string `json:"productId"`
	// Quantity to order
	Quantity int32 `json:"quantity"`
}

// Input for creating a new product
type CreateProductInput struct {
	// Product name
	Name string `json:"name"`
	// Product description (optional)
	Description *string `json:"description,omitempty"`
	// Stock Keeping Unit (must be unique)
	Sku string `json:"sku"`
	// Product price
	Price float64 `json:"price"`
	// Initial stock quantity
	Stock int32 `json:"stock"`
	// Category ID this product belongs to
	CategoryID string `json:"categoryId"`
	// Whether the product is active (defaults to true)
	IsActive *bool `json:"isActive,omitempty"`
}

// Input for creating a new user
type CreateUserInput struct {
	// Full name of the user
	Name string `json:"name"`
	// Email address (must be unique)
	Email string `json:"email"`
}

// Customer order summary
type CustomerOrderSummary struct {
	// Customer information
	Customer *domain.Customer `json:"customer"`
	// Total orders placed
	TotalOrders int32 `json:"totalOrders"`
	// Total amount spent
	TotalSpent float64 `json:"totalSpent"`
	// Last order date
	LastOrderDate *time.Time `json:"lastOrderDate,omitempty"`
}

// Customer statistics
type CustomerStats struct {
	// Total number of customers
	TotalCustomers int32 `json:"totalCustomers"`
	// New customers this month
	NewCustomersThisMonth int32 `json:"newCustomersThisMonth"`
	// Customers with orders
	CustomersWithOrders int32 `json:"customersWithOrders"`
	// Top customers by order value
	TopCustomers []*CustomerOrderSummary `json:"topCustomers"`
}

// Root mutation type providing write access to all entities
type Mutation struct {
}

// Input for filtering orders
type OrderFilterInput struct {
	// Filter by customer ID
	CustomerID *string `json:"customerId,omitempty"`
	// Filter by order status
	Status *domain.OrderStatus `json:"status,omitempty"`
	// Filter by date range - start date
	StartDate *time.Time `json:"startDate,omitempty"`
	// Filter by date range - end date
	EndDate *time.Time `json:"endDate,omitempty"`
}

// Order statistics
type OrderStats struct {
	// Total number of orders
	TotalOrders int32 `json:"totalOrders"`
	// Total revenue
	TotalRevenue float64 `json:"totalRevenue"`
	// Orders by status
	OrdersByStatus []*OrderStatusCount `json:"ordersByStatus"`
	// Average order value
	AverageOrderValue float64 `json:"averageOrderValue"`
	// Orders today
	OrdersToday int32 `json:"ordersToday"`
	// Revenue today
	RevenueToday float64 `json:"revenueToday"`
}

// Order count by status
type OrderStatusCount struct {
	// Order status
	Status domain.OrderStatus `json:"status"`
	// Number of orders with this status
	Count int32 `json:"count"`
}

// Input for filtering and pagination
type PaginationInput struct {
	// Maximum number of items to return (default: 10, max: 100)
	Limit *int32 `json:"limit,omitempty"`
	// Number of items to skip (default: 0)
	Offset *int32 `json:"offset,omitempty"`
}

// Input for filtering products
type ProductFilterInput struct {
	// Filter by category ID
	CategoryID *string `json:"categoryId,omitempty"`
	// Filter by active status
	IsActive *bool `json:"isActive,omitempty"`
	// Search by name or description
	Search *string `json:"search,omitempty"`
	// Minimum price
	MinPrice *float64 `json:"minPrice,omitempty"`
	// Maximum price
	MaxPrice *float64 `json:"maxPrice,omitempty"`
	// Minimum stock
	MinStock *int32 `json:"minStock,omitempty"`
}

// Product statistics
type ProductStats struct {
	// Total number of products
	TotalProducts int32 `json:"totalProducts"`
	// Active products
	ActiveProducts int32 `json:"activeProducts"`
	// Inactive products
	InactiveProducts int32 `json:"inactiveProducts"`
	// Low stock products (stock < 10)
	LowStockProducts int32 `json:"lowStockProducts"`
	// Out of stock products
	OutOfStockProducts int32 `json:"outOfStockProducts"`
	// Total inventory value
	TotalInventoryValue float64 `json:"totalInventoryValue"`
}

// Root query type providing read access to all entities
type Query struct {
}

// Input for updating an existing category
type UpdateCategoryInput struct {
	// Category name
	Name *string `json:"name,omitempty"`
	// Category description
	Description *string `json:"description,omitempty"`
	// Parent category ID (null for root categories)
	ParentID *string `json:"parentId,omitempty"`
}

// Input for updating an existing customer
type UpdateCustomerInput struct {
	// Customer's first name
	FirstName *string `json:"firstName,omitempty"`
	// Customer's last name
	LastName *string `json:"lastName,omitempty"`
	// Phone number
	Phone *string `json:"phone,omitempty"`
	// Street address
	Address *string `json:"address,omitempty"`
	// City
	City *string `json:"city,omitempty"`
	// State or province
	State *string `json:"state,omitempty"`
	// ZIP or postal code
	ZipCode *string `json:"zipCode,omitempty"`
	// Country
	Country *string `json:"country,omitempty"`
}

// Input for updating an existing order
type UpdateOrderInput struct {
	// Order status
	Status *domain.OrderStatus `json:"status,omitempty"`
	// Shipping address
	ShippingAddress *string `json:"shippingAddress,omitempty"`
	// Billing address
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Additional notes
	Notes *string `json:"notes,omitempty"`
	// Date when the order was shipped
	ShippedDate *time.Time `json:"shippedDate,omitempty"`
	// Date when the order was delivered
	DeliveredDate *time.Time `json:"deliveredDate,omitempty"`
}

// Input for updating an existing product
type UpdateProductInput struct {
	// Product name
	Name *string `json:"name,omitempty"`
	// Product description
	Description *string `json:"description,omitempty"`
	// Stock Keeping Unit (must be unique)
	Sku *string `json:"sku,omitempty"`
	// Product price
	Price *float64 `json:"price,omitempty"`
	// Stock quantity
	Stock *int32 `json:"stock,omitempty"`
	// Category ID this product belongs to
	CategoryID *string `json:"categoryId,omitempty"`
	// Whether the product is active
	IsActive *bool `json:"isActive,omitempty"`
}

// Input for updating an existing user
type UpdateUserInput struct {
	// Full name of the user
	Name *string `json:"name,omitempty"`
	// Email address (must be unique)
	Email *string `json:"email,omitempty"`
}

// Authentication scope
type AuthScope string

const (
	AuthScopeAny      AuthScope = "ANY"
	AuthScopeUser     AuthScope = "USER"
	AuthScopeCustomer AuthScope = "CUSTOMER"
)

var AllAuthScope = []AuthScope{
	AuthScopeAny,
	AuthScopeUser,
	AuthScopeCustomer,
}

func (e AuthScope) IsValid() bool {
	switch e {
	case AuthScopeAny, AuthScopeUser, AuthScopeCustomer:
		return true
	}
	return false
}

func (e AuthScope) String() string {
	return string(e)
}

func (e *AuthScope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuthScope", str)
	}
	return nil
}

func (e AuthScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AuthScope) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AuthScope) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
